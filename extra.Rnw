%First, the optimal window widths were determined using a systematic approach that evaluated different width combinations for day, hour, and tide. 
<<win_wid, eval = F, echo = F>>=
##
# window widths to eval, grd_len x 3
grd_len <- 1
jday_wins <- round(seq(1,5, length = grd_len))
hour_wins <- round(seq(0.5, length = grd_len), 2)
dtide_rng <- diff(range(DO_sim$dTide, na.rm = T))/2
dtide_wins <- 0.4#seq(0.1, dtide_rng, length = grd_len)

# combined widths to eval 
grd_wins <- expand.grid(jday_wins, hour_wins, dtide_wins)
names(grd_wins) <- c('jday', 'hour', 'dTide')

# save grid for later
save(grd_wins, file = 'grd_wins.RData')

# setup parallel 
cl <- makeCluster(8)
registerDoParallel(cl)

strt <- Sys.time()
# for each window combination...
res  <- foreach(val = 1:nrow(grd_wins)) %dopar% {

  # progress
  sink('log.txt')
  cat('Log entry time', as.character(Sys.time()), '\n')
  cat(val, ' of ', nrow(grd_wins), '\n')
  print(Sys.time() - strt)
  sink()
    
  # windows to check
  grd_win <- list(
    jday = grd_wins[val, 1],
    hour = grd_wins[val, 2],
    dTide = grd_wins[val, 3]
    )
  
  # get predicted values for each row in DO_sim
  row_out <- matrix(nrow  = nrow(DO_sim), ncol = 2)
  for(row in 1:nrow(DO_sim)){  
    
    # row of data to eval
    ref_in <- DO_sim[row, ]
    
    # get wts for the row given window
    ref_wts <- wt_fun(ref_in, DO_sim, wins = grd_win)
  
    #OLS wtd model
    mod_md <- lm(
      DO_obs ~ dec_time + dTide + 
        sin(2*pi*dec_time) + cos(2*pi*dec_time),
      weights = ref_wts,
      data = DO_sim
      )
    
    # predicted value from model
    fit_md <- predict(
      mod_md,
      newdata = data.frame(dec_time = ref_in$dec_time, dTide = ref_in$dTide)
      )

    # estimated coefficient from model for tide
    beta_md <- mod_md$coefficients['dTide']
  
    #append to row out for each unique sal
    row_out[row, ] <- c(fit_md, beta_md)
      
    }
    
    # return estimates for each window combination
    row_out

  }
# close parallel connection when done
stopCluster(cl)

# save output for all window combinations
sim_win <- res
save(sim_win, file = 'sim_win.RData')
@
% figure of predictions for each window combination
<<win_pred, fig.width = 7.5, fig.height = 4, echo = F, eval = F>>=
# grid chk data from previous chunk
load('sim_win.RData')

# add time vector to results for each window
sim_win <- lapply(
  sim_win, 
  function(x) data.frame(DateTimeStamp = DO_sim$DateTimeStamp, 
    pred = x[,1], parm = x[,2])
  )

# melt list to data frame
sim_win <- melt(sim_win, id.var = names(sim_win[[1]]))

# # merge window results with simulated for plotting
# sim_win <- merge(sim_win, DO_sim[,c('DateTimeStamp', 'DO_obs')], 
#   by = 'DateTimeStamp')
pt_tmp <- DO_sim
pt_tmp$L1  <- NA

# plot of precisions for each wind combination, compared to obs
p <- ggplot(sim_win, aes(x = DateTimeStamp, y = pred, group = L1)) + 
  geom_line(colour = 'gray', alpha = 0.5) +
  geom_point(data = pt_tmp, aes(x = DateTimeStamp, y = DO_obs), 
    alpha = 0.3) +
  theme_bw() + 
  theme(legend.position = 'none') +
  ylab('Predicted values for each window combination')
print(p)
@
%The optimal window widths were those that minimized the root mean square error value between the observed (simulated) and predicted DO values.
<<win_min, fig.width = 8, fig.height = 3, eval = F, echo = F>>=
# grid chk data from previous chunk
load('sim_win.RData')

# add time vector to results for each window
sim_win <- lapply(
  sim_win, 
  function(x) data.frame(DateTimeStamp = DO_sim$DateTimeStamp, 
    pred = x[,1], parm = x[,2])
  )

# melt list to data frame
sim_win <- melt(sim_win, id.var = names(sim_win[[1]]))

# merge window results with simulated for plotting
sim_win <- merge(sim_win, DO_sim[,c('DateTimeStamp', 'DO_obs')], 
  by = 'DateTimeStamp')

# get rmse of pred for each window comb, as list
min_err <- lapply(
  split(sim_win, sim_win$L1), 
  function(x){
  
    x <- na.omit(x[, c('pred', 'DO_obs')])
  
    pred <- x$pred
    obs <- x$DO_obs
    rmse(obs, pred)
 
  })

# load window evaluation grid
load('grd_wins.RData')

# combine rmse of prediction with window values
min_err <- data.frame(grd_wins, err = unlist(min_err))

# error surface for window combs
ggplot(min_err, aes(x = factor(jday), y = factor(hour), z = err, 
    fill = err)) + 
  geom_tile() + 
  scale_fill_gradientn(colours=rev(rainbow(3))) +
  facet_wrap(~dTide, ncol = 5)

# save
save(min_err, file = 'min_err.RData')

# index of window combination that had minimum error
min_ind <- which.min(min_err$err)

# plot
p <- ggplot(DO_sim, aes(x = DateTimeStamp, y = DO_obs)) +
  geom_point() +
  geom_line(aes(y = sim_win[sim_win$L1 == min_ind, 'pred']), colour = 'red') + 
  theme_bw() + 
  ylab('Predicted (line) and observed (point)')
print(p)
@



% compare grid predicted values from values using actual tide
<<pred_comp, fig.height = 4, fig.width = 4, eval = F, echo = F>>=
# predicted values using actual tides
pred_act <- sim_win[sim_win$L1 == min_ind, 'pred']
#plot comparison
p <- ggplot(data.frame(pred_int = pred$DO_pred, pred_act), 
  aes(x = pred_int, y = pred_act)) + 
  geom_point(alpha = 0.6) + 
  geom_abline(slope = 1, intercept = 0, colour = 'red') + 
  theme_bw()
print(p)
@

wt_fun<-function(ref_in, dat_in,
  wt_vars = c('jday', 'hour', 'dTide'),
  wins = list(2, 0.25, 0.2),
  all = F){
  
#   # for subroutine
#   dat_in <- DO_sim
#   ref_in <- dat_in[1,]
#   wt_vars = c('jday', 'hour', 'dTide')
#   wins = list(5, 0.23, 2.651631) #list(15, 0.5, NULL)
  
  # sanity check
  if(sum(wt_vars %in% names(dat_in)) != length(wt_vars))
    stop('Weighting variables must be named in "dat_in"')
  
  # windows for each of three variables
  wins_1<-wins[[1]]
  wins_2<-wins[[2]]
  wins_3<-wins[[3]]
  
  # default window width for third variable is half its range
  if(is.null(wins[[3]])) wins_3 <- diff(range(dat_in[, wt_vars[3]]))/2
  
  # weighting tri-cube function
  # mirror extends weighting function if vector repeats, e.g. monthly
  # 'dat_cal' is observation for weight assignment
  # 'ref' is reference observation for fitting the model
  # 'win' is window width from above (divided by two)
  # 'mirr' is logical indicating if distance accounts for repeating variables (e.g., month)
  # 'scl_val' is range for the ref vector of obs, used to get correct distance for mirrored obs
  wt_fun_sub <- function(dat_cal, ref, win, mirr = F, scl_val = 1){
    
    # dist_val is distance of value from the ref
    dist_val <- abs(dat_cal - ref)
    
    # repeat if distance is checked on non-continuous number line
    if(mirr)
      dist_val <- pmin(
        dist_val, 
        abs(dat_cal - ref + scl_val),
        abs(dat_cal - scl_val - ref)
        )
    
    # get wts within window, otherwise zero
    win_out <- dist_val > win
    dist_val <- (1 - (dist_val/win)^3)^3
    dist_val[win_out] <- 0
      
    return(dist_val)
      
    }

  #reference (starting) data
  ref_1 <- as.numeric(ref_in[, wt_vars[1]])
  ref_2 <- as.numeric(ref_in[, wt_vars[2]])
  ref_3 <- as.numeric(ref_in[, wt_vars[3]])

  ##
  # weights for each observation in relation to reference
  # see comments for 'wt_fun_sub' for 'scl_val' argument
  
  # jday
  wts_1 <- wt_fun_sub(as.numeric(dat_in[, wt_vars[1]]), 
    ref = ref_1, win = wins_1, mirr = T, scl_val = 365) 
  # hour
  wts_2 <- wt_fun_sub(as.numeric(dat_in[, wt_vars[2]]), 
    ref = ref_2, win = wins_2, mirr = T, scl_val = 1)
  # tide
  wts_3 <- wt_fun_sub(as.numeric(dat_in[, wt_vars[3]]), 
    ref = ref_3, win = wins_3)
  # all as product 
  out <- wts_1 * wts_2 * wts_3
  
  gr_zero <- sum(out > 0)
  #cat('   Number of weights greater than zero =',gr.zero,'\n')
  
  # extend window widths of weight vector is less than 100
  while(gr_zero < 100){
    
    wins_1 <- 0.1*wins_1 + wins_1
    wins_2 <- 0.1*wins_2 + wins_2
    wins_3 <- 0.1*wins_3 + wins_3
    
    #weights for each observation in relation to reference
    wts_1 <- sapply(as.numeric(dat_in[, wt_vars[1]]), wt_fun_sub, 
      ref = ref_1, win = wins_1, mirr = T, scl_val = 365)
    wts_2 <- sapply(as.numeric(dat_in[, wt_vars[2]]), wt_fun_sub, 
      ref = ref_2, win = wins_2, scl_val = 1)
    wts_3 <- sapply(as.numeric(dat_in[, wt_vars[3]]), wt_fun_sub, 
      ref = ref_3, win = wins_3)
    
    out <- wts_1 * wts_2 * wts_3
    
    gr_zero <- sum(out>0)
    
    }
  
  #return all weights if T
  if(all){
    out <- data.frame(wts_1, wts_2, wts_3)
    names(out) <- wt_vars
    return(out)
    }
  
  #final weights are product of all three
  out
  
  }
  
% normalization using tidal values that occur at each hour across thep eriod of obs, this was not used
# for(val in 1:nrow(norm)){
#   
#   cat(val, '\t')
#   
#   # row to normalize
#   to_nrm <- norm[val, ]
#   
#   # corresponding values for datetimestamp on int_grd
#   day_int <- sim_grd[sim_grd$DateTimeStamp == to_nrm$DateTimeStamp,]
#   
#   # find all obs tidal values at the same time as to_nrm
#   dtide_nrm <- norm[norm$hr == to_nrm$hr, 'dTide.x']
#   
#   # DO values to normalize
#   # matches all tides occuring at the hour to those in day_int
#   DO_vals <- merge(
#     data.frame(dTide = dtide_nrm), 
#     day_int[, c('DO_pred', 'dTide')], 
#     by = 'dTide', all.x = T
#     )
#   
#   # take ave
#   DO_nrm <- mean(DO_vals$DO_pred)
#   
#   # append to data
#   norm[val, 'DO_nrm'] <- DO_nrm
#   
#   }
